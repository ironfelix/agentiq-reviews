# РЕВЬЮ ПАЙПЛАЙНА: Сбор отзывов -> Анализ -> Карточка

> Разбор всей цепочки, где теряются данные, и что нужно исправить

---

## Пайплайн (как работает сейчас)

```
1. Пользователь вводит артикул (370907224)
       ↓
2. Celery task -> WBCON API: create_task_fb
       ↓
3. WBCON API: task_status (polling)
       ↓
4. WBCON API: get_results_fb (пагинация по 100)
       ↓
5. wbcon-task-to-card-v2.py: анализ отзывов
       ↓
6. JSON карточки -> БД (reports.data)
       ↓
7. FastAPI -> Jinja2 template -> HTML в браузере
```

---

## Шаг 1-4: Сбор данных (WBCON API)

### Что получаем из API:

```json
{
  "feedback_count": 577,
  "rating": 4.82,
  "feedbacks": [
    {
      "fb_text": "Перестал работать на следующий день",
      "valuation": "1",
      "color": "белый",
      "size": "",
      "advantages": "",
      "disadvantages": "Деньги на ветер :(",
      "answer_text": "..." (ответ продавца),
      "fb_created_at": "2025-01-09T14:07:22Z"
    }
  ]
}
```

### Какие варианты (цвета) реально есть в данных:

| Вариант | Кол-во отзывов |
|---------|----------------|
| белый | 23 |
| голубой | 16 |
| черный | 16 |
| Белый иней | 9 |
| Черный 0.45 л | 8 |
| Зеленый 0.45 л | 7 |
| зеленый | 7 |
| Белый 0.45 л | 4 |
| белый иней | 3 |
| Бежевый 0.45 л | 2 |
| желтый | 1 |

### ПРОБЛЕМА 1: В карточке показывается только "черный"

**Почему?** Скрипт берёт **3 варианта** для отображения:
1. `target_variant` — вариант с худшим рейтингом (черный: 4.5)
2. `compare_variants[0]` — 2й вариант (для сравнения)
3. `compare_variants[1]` — 3й вариант (для сравнения)

Но `compare_variants` пуст! Потому что:

```python
# Код в wbcon-task-to-card-v2.py:
compare_variants = [v for v in valid_colors if v != target_variant]
```

`valid_colors` фильтруется через `is_color_variant()` которая проверяет что строка — это цвет. Проблема: варианты типа "Черный · 0.45 л" или "Белый иней" могут не проходить фильтр.

Также: "белый" и "белый иней" и "Белый · 0.45 л" — это разные записи, хотя по факту один цвет. Нужна нормализация.

### ПРОБЛЕМА 2: Пагинация загружает 5000 записей вместо 577

API отдаёт по 100 отзывов, но продолжает отдавать данные даже после 577 (дубли?). Safety limit в 5000 спасает от бесконечного цикла, но задача работает ~100 секунд вместо ~10.

**Решение:** Остановить пагинацию когда `offset >= feedback_count`.

---

## Шаг 5: Анализ (wbcon-task-to-card-v2.py)

### Reasoning: Как определяются причины

1. Для каждого отзыва берём 3 текстовых поля:
   - `disadvantages` — минусы (точно негатив)
   - `advantages` — плюсы (если оценка <= 3, люди пишут жалобы сюда)
   - `fb_text` — основной текст (fallback)

2. Текст нормализуется (lowercase, убираем спецсимволы)

3. Ищем паттерны из словаря REASONS:
   ```
   UNIVERSAL_REASONS (всегда):
     defect:    ["брак", "дефект", "сломал", "не работа"]
     mismatch:  ["не соответств", "описани", "ожидал"]
     delivery:  ["доставк", "помят", "упаковк"]

   CATEGORY_PRESETS[flashlight] (если категория = flashlight):
     brightness: ["свет", "ярк", "туск"]
     battery:    ["аккум", "заряд", "батар"]
     waterproof: ["вод", "влаг", "промок"]
     build:      ["сборк", "люфт", "хлипк"]
   ```

4. Если ни один паттерн не сработал -> "other" (Прочее)

### ПРОБЛЕМА 3: 67% "Прочее" — причины не распознаются

**Почему?** Категория определена как `general` (fallback), поэтому используются ТОЛЬКО 3 универсальных паттерна:
- defect (брак, дефект, сломал, не работа)
- mismatch (не соответствует, описание)
- delivery (доставка, помят, упаковка)

Реальные негативные отзывы по этому товару (чайник):
- "Привезли без шнура" -> не ловится (нет паттерна "шнур", "кабель")
- "Не кипятит" -> не ловится (нет паттерна "кипят", "нагрев")
- "Перестал работать" -> ловится как "defect" ("не работа")
- "Упаковали повторно" -> не ловится точно

**Решение:** Добавить категорию `kitchen` с паттернами:
```python
"kitchen": {
    "not_heating": {
        "label": "Не нагревает / не кипятит",
        "patterns": ["не кипят", "не грет", "не нагрев", "холодн", "не горяч"]
    },
    "leaking": {
        "label": "Протекает",
        "patterns": ["проте", "течет", "теч", "капает", "вод"]
    },
    "cable": {
        "label": "Проблемы с кабелем / зарядкой",
        "patterns": ["шнур", "кабел", "провод", "зарядк", "usb"]
    },
    "stopped_working": {
        "label": "Перестал работать",
        "patterns": ["перестал", "не включ", "сгорел", "вышел из строя"]
    }
}
```

### ПРОБЛЕМА 4: Категория не определяется

Для артикула 370907224 (чайник) категория = `general` потому что:
1. `product_name` пустой (WBCON API не возвращает название товара)
2. В текстах отзывов нет слов из CATEGORY_KEYWORDS (чайник, кастрюля и т.д.)
3. Fallback = `general` (раньше был `flashlight`)

**Решение:**
- Добавить "чайник" в CATEGORY_KEYWORDS
- Парсить название товара из WB Card API (`card.wb.ru`)
- Или определять категорию по частотным словам в отзывах ("кипятит", "нагревает", "литр" -> kitchen)

---

## Шаг 6: JSON карточки

### Что генерируется vs что должно быть:

| Поле | Сейчас | Должно быть |
|------|--------|-------------|
| signal.title | "Проблема в варианте: черный" | OK (исправлено) |
| signal.scores | Только черный, остальные "—" | Все варианты с рейтингами |
| reasons | 67% Прочее, 33% Брак | Реальные причины: "Перестал работать", "Нет шнура" |
| risk.items | Статика: "падение конверсии 3-6%" | Рассчитывать из данных |
| actions | Универсальные | На основе реальных причин |
| reply.draft | Универсальный шаблон | На основе top причины |
| header.product_name | "Артикул 370907224" | Название товара из WB |
| header.unanswered_count | 0 | Считать из answer_text == "" |

---

## Шаг 7: Рендеринг

### Как template использует данные:

```
report.html получает:
  - data (JSON из БД)
  - report (SQLAlchemy модель)

Рендерит:
  data.header.product_name -> заголовок
  data.header.feedback_count -> "577 отзывов"
  data.header.rating -> "4.82"
  data.signal.title -> "Проблема в варианте: черный"
  data.signal.scores[] -> бары с рейтингами вариантов
  data.reasons.items[] -> причины с процентами
  data.risk.items[] -> список рисков
  data.actions.items[] -> список действий
  data.reply.text -> черновик ответа
```

### Template рендерит данные корректно, проблема в качестве данных.

---

## ПЛАН ИСПРАВЛЕНИЙ (приоритет)

### 1. [CRITICAL] Добавить категории товаров

```python
CATEGORY_KEYWORDS = {
    ...
    "kitchen": ["чайник", "кастрюл", "сковород", "термос", "термокружк",
                "блендер", "миксер", "тостер", "микроволн", "мультиварк",
                "кофевар", "чайный", "кипят", "литр"],
    "home": ["постель", "полотенц", "подушк", "одеяло", "плед",
             "штор", "ковр", "матрас"],
    "beauty": ["крем", "маска", "шампунь", "косметик", "помад",
               "тушь", "пудр", "тональ"],
    "toys": ["игрушк", "кукл", "конструктор", "машинк", "пазл",
             "мягк", "плюшев"],
    "auto": ["автомобил", "машин", "руль", "бампер", "фар"],
    "sports": ["гантел", "коврик", "тренажер", "мяч", "скакалк"],
}
```

### 2. [CRITICAL] Нормализация вариантов

```python
def normalize_variant(raw: str) -> str:
    """'Черный · 0.45 л' -> 'черный', 'белый иней' -> 'белый'"""
    v = raw.lower().strip()
    # Убрать размер/объём
    v = re.sub(r'[·\-]\s*\d+.*$', '', v).strip()
    # Убрать модификаторы
    v = re.sub(r'\s+(иней|металлик|перламутр)$', '', v).strip()
    return v
```

### 3. [HIGH] Добавить CATEGORY_PRESETS для kitchen

```python
"kitchen": {
    "not_heating": {"label": "Не нагревает / не кипятит",
                    "patterns": ["не кипят", "не грет", "не нагрев", "холодн"]},
    "leaking": {"label": "Протекает",
                "patterns": ["проте", "течет", "капает", "вод"]},
    "cable": {"label": "Проблемы с кабелем",
              "patterns": ["шнур", "кабел", "провод", "зарядк"]},
    "stopped_working": {"label": "Перестал работать",
                        "patterns": ["перестал", "не включ", "сгорел"]},
    "noise": {"label": "Шумит / гудит",
              "patterns": ["шум", "гуд", "громк", "тих"]},
}
```

### 4. [HIGH] Рассчитывать unanswered_count

```python
unanswered = sum(1 for f in feedbacks if not f.get("answer_text"))
```

### 5. [MEDIUM] Остановить пагинацию раньше

```python
# В fetch_all_feedbacks:
if offset >= feedback_count:
    break
```

### 6. [MEDIUM] Рассчитывать риски динамически

```python
neg_rate = negative_count / total_count
if neg_rate > 0.15:
    risk = "Высокий: более 15% негативных отзывов"
elif neg_rate > 0.08:
    risk = "Средний: 8-15% негативных отзывов"
```

### 7. [LOW] Получать название товара из WB API

```python
import requests
def get_product_name(article_id: int) -> str:
    url = f"https://card.wb.ru/cards/v2/detail?nm={article_id}"
    data = requests.get(url).json()
    return data["data"]["products"][0]["name"]
```

---

## ИТОГО: Корневые проблемы

1. **Категория не определяется** -> fallback "general" -> нет специфичных паттернов -> 67% "Прочее"
2. **Варианты не нормализуются** -> "белый", "Белый иней", "Белый 0.45 л" считаются разными -> в карточке только 1 вариант
3. **Паттерны причин слишком узкие** -> для чайника нет "не кипятит", "нет шнура", "перестал работать"
4. **Пагинация не останавливается** -> загружает 5000 вместо 577 -> задача 100 сек вместо 10
5. **Риски/actions/reply статичные** -> не отражают реальные проблемы товара

---

**Статус:** Ревью завершено
**Дата:** 2026-02-06
