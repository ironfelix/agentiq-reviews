#!/usr/bin/env python3
"""Run pilot QA matrix against chat-center API and write markdown report.

Default mode is safe:
- sync + draft + metrics/readiness checks
- no live replies are sent unless --send-replies is explicitly enabled
"""

from __future__ import annotations

import argparse
import asyncio
import json
import os
from dataclasses import dataclass
from datetime import datetime, timezone
from pathlib import Path
from typing import Any, Optional

import httpx


@dataclass
class StepResult:
    code: str
    title: str
    status: str  # pass|warn|fail|skip
    details: str


def utc_now_iso() -> str:
    return datetime.now(timezone.utc).replace(microsecond=0).isoformat()


def short_json(value: Any, limit: int = 280) -> str:
    text = json.dumps(value, ensure_ascii=False, default=str)
    if len(text) <= limit:
        return text
    return text[: limit - 3] + "..."


def build_headers(token: Optional[str]) -> dict[str, str]:
    headers = {"Content-Type": "application/json"}
    if token:
        headers["Authorization"] = f"Bearer {token}"
    return headers


async def api_request(
    client: httpx.AsyncClient,
    method: str,
    url: str,
    *,
    token: Optional[str] = None,
    json_body: Optional[dict[str, Any]] = None,
    params: Optional[dict[str, Any]] = None,
) -> tuple[int, Any]:
    try:
        response = await client.request(
            method=method,
            url=url,
            headers=build_headers(token),
            json=json_body,
            params=params,
            timeout=45.0,
        )
    except httpx.RequestError as exc:
        return 0, {"error": str(exc), "url": url}
    try:
        payload = response.json()
    except Exception:
        payload = {"raw": response.text}
    return response.status_code, payload


def parse_args() -> argparse.Namespace:
    parser = argparse.ArgumentParser(description="Pilot QA matrix runner")
    parser.add_argument(
        "--base-url",
        default=os.getenv("AGENTIQ_API_BASE_URL", "http://localhost:8001/api"),
        help="Chat-center API base URL",
    )
    parser.add_argument(
        "--email",
        default=os.getenv("AGENTIQ_PILOT_EMAIL"),
        help="Seller email for login/register",
    )
    parser.add_argument(
        "--password",
        default=os.getenv("AGENTIQ_PILOT_PASSWORD"),
        help="Seller password for login/register",
    )
    parser.add_argument(
        "--name",
        default=os.getenv("AGENTIQ_PILOT_NAME", "Pilot QA Seller"),
        help="Seller name for auto-register",
    )
    parser.add_argument(
        "--marketplace",
        default=os.getenv("AGENTIQ_PILOT_MARKETPLACE", "wildberries"),
        help="Marketplace for register flow",
    )
    parser.add_argument(
        "--api-key",
        default=os.getenv("WB_API_KEY") or os.getenv("AGENTIQ_WB_API_KEY"),
        help="WB API key for connect-marketplace",
    )
    parser.add_argument(
        "--register-if-needed",
        action="store_true",
        help="Register user if login fails",
    )
    parser.add_argument(
        "--connect-if-needed",
        action="store_true",
        help="Connect WB API key if seller has no API credentials",
    )
    parser.add_argument(
        "--max-items",
        type=int,
        default=120,
        help="max_items for review/question/chat sync endpoints",
    )
    parser.add_argument(
        "--sync-timeout-sec",
        type=int,
        default=90,
        help="timeout to wait for sync status transition",
    )
    parser.add_argument(
        "--send-replies",
        action="store_true",
        help="Actually send replies via /reply endpoints (live action)",
    )
    parser.add_argument(
        "--min-reply-activity",
        type=int,
        default=1,
        help="Min reply activity threshold for pilot-readiness check",
    )
    parser.add_argument(
        "--reply-activity-window-days",
        type=int,
        default=30,
        help="Rolling window in days for reply-activity baseline",
    )
    parser.add_argument(
        "--output",
        default="",
        help="Output markdown file path (default autogenerated in docs/product/reports)",
    )
    return parser.parse_args()


def ensure_output_path(custom_path: str) -> Path:
    if custom_path:
        path = Path(custom_path).expanduser().resolve()
    else:
        ts = datetime.now().strftime("%Y%m%d-%H%M%S")
        path = (
            Path(__file__).resolve().parents[4]
            / "docs"
            / "product"
            / "reports"
            / f"pilot-qa-report-{ts}.md"
        )
    path.parent.mkdir(parents=True, exist_ok=True)
    return path


def pick_interaction(payload: dict[str, Any]) -> Optional[dict[str, Any]]:
    items = payload.get("interactions")
    if not isinstance(items, list) or not items:
        return None
    return items[0]


async def run() -> int:
    args = parse_args()
    if not args.email or not args.password:
        print("error: --email and --password are required (or set env vars)")
        return 2

    output_path = ensure_output_path(args.output)
    steps: list[StepResult] = []
    selected_interactions: dict[str, dict[str, Any]] = {}
    readiness_payload: dict[str, Any] = {}
    ops_alerts_payload: dict[str, Any] = {}

    async with httpx.AsyncClient(follow_redirects=True) as client:
        token: Optional[str] = None

        login_code, login_payload = await api_request(
            client,
            "POST",
            f"{args.base_url}/auth/login",
            json_body={"email": args.email, "password": args.password},
        )

        if login_code in (200, 201):
            token = login_payload.get("access_token")
            steps.append(StepResult("auth_login", "Login", "pass", "Успешный login"))
        elif args.register_if_needed:
            reg_code, reg_payload = await api_request(
                client,
                "POST",
                f"{args.base_url}/auth/register",
                json_body={
                    "email": args.email,
                    "password": args.password,
                    "name": args.name,
                    "marketplace": args.marketplace,
                },
            )
            if reg_code in (200, 201):
                token = reg_payload.get("access_token")
                steps.append(StepResult("auth_register", "Register", "pass", "Пользователь зарегистрирован"))
            else:
                steps.append(
                    StepResult(
                        "auth_register",
                        "Register",
                        "fail",
                        f"register failed: {reg_code} {short_json(reg_payload)}",
                    )
                )
        else:
            steps.append(
                StepResult(
                    "auth_login",
                    "Login",
                    "fail",
                    f"login failed: {login_code} {short_json(login_payload)}",
                )
            )

        if not token:
            write_report(output_path, args, steps, readiness_payload, ops_alerts_payload, selected_interactions)
            print(f"report written: {output_path}")
            return 1

        me_code, me_payload = await api_request(
            client,
            "GET",
            f"{args.base_url}/auth/me",
            token=token,
        )
        if me_code != 200:
            steps.append(StepResult("auth_me", "Get /auth/me", "fail", f"{me_code} {short_json(me_payload)}"))
            write_report(output_path, args, steps, readiness_payload, ops_alerts_payload, selected_interactions)
            print(f"report written: {output_path}")
            return 1

        has_api_credentials = bool(me_payload.get("has_api_credentials"))
        if not has_api_credentials and args.connect_if_needed:
            if not args.api_key:
                steps.append(
                    StepResult(
                        "connect_marketplace",
                        "Connect WB API key",
                        "fail",
                        "seller без credentials и не передан --api-key",
                    )
                )
            else:
                connect_code, connect_payload = await api_request(
                    client,
                    "POST",
                    f"{args.base_url}/auth/connect-marketplace",
                    token=token,
                    json_body={"api_key": args.api_key},
                )
                if connect_code == 200:
                    steps.append(StepResult("connect_marketplace", "Connect WB API key", "pass", "WB ключ подключен"))
                else:
                    steps.append(
                        StepResult(
                            "connect_marketplace",
                            "Connect WB API key",
                            "fail",
                            f"{connect_code} {short_json(connect_payload)}",
                        )
                    )
        elif has_api_credentials:
            steps.append(StepResult("connect_marketplace", "Connect WB API key", "pass", "Credentials уже подключены"))
        else:
            steps.append(
                StepResult(
                    "connect_marketplace",
                    "Connect WB API key",
                    "warn",
                    "Пропущено: нет credentials и connect_if_needed=false",
                )
            )

        sync_now_code, sync_now_payload = await api_request(
            client,
            "POST",
            f"{args.base_url}/auth/sync-now",
            token=token,
            json_body={"include_interactions": True},
        )
        if sync_now_code == 200:
            steps.append(
                StepResult(
                    "sync_now",
                    "Trigger /auth/sync-now",
                    "pass",
                    f"queued={','.join(sync_now_payload.get('queued_scopes') or []) or 'none'}",
                )
            )
            loop = asyncio.get_running_loop()
            deadline = loop.time() + max(5, int(args.sync_timeout_sec))
            final_status = "syncing"
            while loop.time() < deadline:
                me_poll_code, me_poll_payload = await api_request(
                    client,
                    "GET",
                    f"{args.base_url}/auth/me",
                    token=token,
                )
                if me_poll_code != 200:
                    steps.append(
                        StepResult(
                            "sync_poll",
                            "Poll /auth/me during sync",
                            "warn",
                            f"poll failed: {me_poll_code} {short_json(me_poll_payload)}",
                        )
                    )
                    break
                final_status = (me_poll_payload.get("sync_status") or "idle").lower()
                if final_status != "syncing":
                    break
                await asyncio.sleep(3)

            if final_status == "syncing":
                steps.append(
                    StepResult(
                        "sync_poll",
                        "Poll /auth/me during sync",
                        "warn",
                        f"sync_status stayed syncing after {args.sync_timeout_sec}s timeout",
                    )
                )
            elif final_status == "error":
                steps.append(StepResult("sync_poll", "Poll /auth/me during sync", "fail", "sync ended with error"))
            else:
                steps.append(
                    StepResult(
                        "sync_poll",
                        "Poll /auth/me during sync",
                        "pass",
                        f"sync finished with status={final_status}",
                    )
                )
        else:
            steps.append(
                StepResult(
                    "sync_now",
                    "Trigger /auth/sync-now",
                    "warn",
                    f"{sync_now_code} {short_json(sync_now_payload)}",
                )
            )

        for channel, endpoint in (
            ("review", "/interactions/sync/reviews"),
            ("question", "/interactions/sync/questions"),
            ("chat", "/interactions/sync/chats"),
        ):
            sync_params = {"max_items": args.max_items}
            if channel == "chat":
                sync_params["direct_wb_fetch"] = True
            sync_code, sync_payload = await api_request(
                client,
                "POST",
                f"{args.base_url}{endpoint}",
                token=token,
                params=sync_params,
            )
            if sync_code == 200:
                created = int(sync_payload.get("created") or 0)
                updated = int(sync_payload.get("updated") or 0)
                fetched = int(sync_payload.get("fetched") or 0)
                steps.append(
                    StepResult(
                        f"sync_{channel}",
                        f"Sync {channel}",
                        "pass",
                        f"fetched={fetched} created={created} updated={updated}",
                    )
                )
            else:
                steps.append(
                    StepResult(
                        f"sync_{channel}",
                        f"Sync {channel}",
                        "fail",
                        f"{sync_code} {short_json(sync_payload)}",
                    )
                )

        for channel in ("review", "question", "chat"):
            list_code, list_payload = await api_request(
                client,
                "GET",
                f"{args.base_url}/interactions",
                token=token,
                params={"channel": channel, "page_size": 1},
            )
            if list_code != 200:
                steps.append(
                    StepResult(
                        f"list_{channel}",
                        f"List {channel}",
                        "fail",
                        f"{list_code} {short_json(list_payload)}",
                    )
                )
                continue
            interaction = pick_interaction(list_payload)
            if not interaction:
                steps.append(
                    StepResult(
                        f"list_{channel}",
                        f"List {channel}",
                        "warn",
                        "Нет обращений в канале",
                    )
                )
                continue
            selected_interactions[channel] = interaction
            steps.append(
                StepResult(
                    f"list_{channel}",
                    f"List {channel}",
                    "pass",
                    f"interaction_id={interaction.get('id')}",
                )
            )

        for channel, interaction in selected_interactions.items():
            interaction_id = interaction.get("id")
            if not interaction_id:
                continue
            draft_code, draft_payload = await api_request(
                client,
                "POST",
                f"{args.base_url}/interactions/{interaction_id}/ai-draft",
                token=token,
                json_body={"force_regenerate": True},
            )
            if draft_code == 200:
                source = draft_payload.get("source")
                steps.append(
                    StepResult(
                        f"draft_{channel}",
                        f"AI draft {channel}",
                        "pass",
                        f"source={source}",
                    )
                )
            else:
                steps.append(
                    StepResult(
                        f"draft_{channel}",
                        f"AI draft {channel}",
                        "fail",
                        f"{draft_code} {short_json(draft_payload)}",
                    )
                )

            if args.send_replies:
                reply_text = f"[pilot qa {utc_now_iso()}] Спасибо! Проверили обращение."
                reply_code, reply_payload = await api_request(
                    client,
                    "POST",
                    f"{args.base_url}/interactions/{interaction_id}/reply",
                    token=token,
                    json_body={"text": reply_text},
                )
                if reply_code == 200:
                    steps.append(
                        StepResult(
                            f"reply_{channel}",
                            f"Reply {channel}",
                            "pass",
                            "Ответ отправлен",
                        )
                    )
                else:
                    steps.append(
                        StepResult(
                            f"reply_{channel}",
                            f"Reply {channel}",
                            "fail",
                            f"{reply_code} {short_json(reply_payload)}",
                        )
                    )
            else:
                steps.append(
                    StepResult(
                        f"reply_{channel}",
                        f"Reply {channel}",
                        "skip",
                        "Пропущено (safe mode, без --send-replies)",
                    )
                )

        timeline_seed = next(iter(selected_interactions.values()), None)
        if timeline_seed and timeline_seed.get("id"):
            timeline_code, timeline_payload = await api_request(
                client,
                "GET",
                f"{args.base_url}/interactions/{timeline_seed['id']}/timeline",
                token=token,
            )
            if timeline_code == 200:
                steps.append(
                    StepResult(
                        "timeline",
                        "Deterministic timeline",
                        "pass",
                        f"scope={timeline_payload.get('thread_scope')} steps={len(timeline_payload.get('steps') or [])}",
                    )
                )
            else:
                steps.append(
                    StepResult(
                        "timeline",
                        "Deterministic timeline",
                        "fail",
                        f"{timeline_code} {short_json(timeline_payload)}",
                    )
                )
        else:
            steps.append(StepResult("timeline", "Deterministic timeline", "warn", "Нет interaction для проверки"))

        ops_code, ops_payload = await api_request(
            client,
            "GET",
            f"{args.base_url}/interactions/metrics/ops-alerts",
            token=token,
        )
        if ops_code == 200:
            ops_alerts_payload = ops_payload
            alerts_count = len(ops_payload.get("alerts") or [])
            steps.append(StepResult("ops_alerts", "Ops alerts", "pass", f"alerts={alerts_count}"))
        else:
            steps.append(StepResult("ops_alerts", "Ops alerts", "fail", f"{ops_code} {short_json(ops_payload)}"))

        readiness_code, readiness_resp = await api_request(
            client,
            "GET",
            f"{args.base_url}/interactions/metrics/pilot-readiness",
            token=token,
            params={
                "min_reply_activity": args.min_reply_activity,
                "reply_activity_window_days": args.reply_activity_window_days,
            },
        )
        if readiness_code == 200:
            readiness_payload = readiness_resp
            decision = readiness_resp.get("decision")
            summary = readiness_resp.get("summary") or {}
            steps.append(
                StepResult(
                    "pilot_readiness",
                    "Pilot readiness",
                    "pass" if decision == "go" else "warn",
                    (
                        f"decision={decision}, pass={summary.get('passed')}, "
                        f"warn={summary.get('warnings')}, fail={summary.get('failed')}"
                    ),
                )
            )
        else:
            steps.append(
                StepResult(
                    "pilot_readiness",
                    "Pilot readiness",
                    "fail",
                    f"{readiness_code} {short_json(readiness_resp)}",
                )
            )

    write_report(output_path, args, steps, readiness_payload, ops_alerts_payload, selected_interactions)
    print(f"report written: {output_path}")
    return 0


def status_emoji(status: str) -> str:
    return {
        "pass": "[PASS]",
        "warn": "[WARN]",
        "fail": "[FAIL]",
        "skip": "[SKIP]",
    }.get(status, "[INFO]")


def write_report(
    path: Path,
    args: argparse.Namespace,
    steps: list[StepResult],
    readiness_payload: dict[str, Any],
    ops_alerts_payload: dict[str, Any],
    selected_interactions: dict[str, dict[str, Any]],
) -> None:
    now = datetime.now(timezone.utc).strftime("%Y-%m-%d %H:%M:%S UTC")
    decision = readiness_payload.get("decision", "unknown")
    go_no_go = readiness_payload.get("go_no_go")
    summary = readiness_payload.get("summary") or {}
    checks = readiness_payload.get("checks") or []

    lines: list[str] = []
    lines.append("# Pilot QA Report")
    lines.append("")
    lines.append(f"- Generated: {now}")
    lines.append(f"- API: `{args.base_url}`")
    lines.append(f"- Seller: `{args.email}`")
    lines.append(f"- Safe mode: `{not args.send_replies}`")
    lines.append("")
    lines.append("## Run Summary")
    lines.append("")
    lines.append(f"- Decision: `{decision}`")
    if go_no_go is not None:
        lines.append(f"- Go/No-Go: `{'GO' if go_no_go else 'NO-GO'}`")
    if summary:
        lines.append(
            f"- Checks: total={summary.get('total_checks')}, pass={summary.get('passed')}, "
            f"warn={summary.get('warnings')}, fail={summary.get('failed')}"
        )
        blockers = summary.get("blockers") or []
        lines.append(f"- Blockers: `{', '.join(blockers) if blockers else 'none'}`")
    lines.append("")
    lines.append("## Matrix Steps")
    lines.append("")
    for step in steps:
        lines.append(f"- {status_emoji(step.status)} `{step.code}` {step.title}: {step.details}")
    lines.append("")
    lines.append("## Selected Interactions")
    lines.append("")
    if selected_interactions:
        for channel, interaction in selected_interactions.items():
            lines.append(
                f"- `{channel}`: id={interaction.get('id')}, external_id={interaction.get('external_id')}, "
                f"status={interaction.get('status')}, needs_response={interaction.get('needs_response')}"
            )
    else:
        lines.append("- none")
    lines.append("")
    lines.append("## Pilot Readiness Checks")
    lines.append("")
    if checks:
        for check in checks:
            lines.append(
                f"- {status_emoji(check.get('status', 'info'))} `{check.get('code')}` "
                f"(blocker={check.get('blocker')}): {check.get('details')}"
            )
    else:
        lines.append("- readiness payload unavailable")
    lines.append("")
    lines.append("## Ops Alerts Snapshot")
    lines.append("")
    if ops_alerts_payload:
        alerts = ops_alerts_payload.get("alerts") or []
        lines.append(f"- Alerts count: `{len(alerts)}`")
        for alert in alerts:
            lines.append(
                f"- `{alert.get('severity')}` `{alert.get('code')}`: "
                f"{alert.get('title')} - {alert.get('message')}"
            )
    else:
        lines.append("- ops alerts unavailable")

    path.write_text("\n".join(lines) + "\n", encoding="utf-8")


if __name__ == "__main__":
    raise SystemExit(asyncio.run(run()))
